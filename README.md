Summarize the Project and the problem it was solving:

This project was a TI board program on an embedded system that is meant to behave similar to a thermostat. It constantly loops in 1000, 200 and 500 millisecond intervals to check the states of its buttons and its saved values. The program will then adjust the temperature variable and the LEDs on the board, depending out those inputs. This program utilizes various drivers to accomplish this task, which can be read in the source code's header files.


What did you do particularly well?:

I would say that the thing I did well is my usual strength with coding. I tend to be pretty neat and organized with things. Given, there are still some artifacts left over from the first gpio assignment I did in the course that are in the source code, everything is quite organized and spaced out for readability. I used to go crazy and comment everything erroneously, but I've since slowed down on that and tend to focus on dumbing the code down by directing a potential editor that is not myself.


Where could you improve?:

I feel like my general understanding of how this project works could use help. Beyond that, I think there must be other more efficient ways to write a similar program that make more sense as well.


What tools and/or resources are you adding to your support network?:

I'm not sure I understand the question. Are you asking what I used for tools and resources to complete the trask? Because that would consist of Lucidchart for the UML document, OpenOffice for the text files and Code Composer Studio from TI instruments.


What skills from this project will be particularly transferable to other projects and/or course work?:

Generally speaking, I look at every coding project as a learning experience in both a new way to think about a problem I am solving as well as a new tool that I am using. While I don't particularly see myself using Code Composer Studio in the future, I'm sure that if I am ever working on an embedded system that I will remember some of the fundamentals of this course at the bare minimum.


How did you make this project maintainable, readable and adaptable?:

To start, again, I like neatness and readability. So I space things. I tab them out. I organize them into obvious blocks to know where they belong. Adaptability and Maintainability come with the territory if you just follow object orientation principles. Particularly polymorphism. I just create my functions to be general use for things. If it can be called for tasks other than for what it is specifically designed for then it passes the bar.
